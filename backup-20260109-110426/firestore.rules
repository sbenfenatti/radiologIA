rules_version = '2';

/**
 * This ruleset enforces a strict user-ownership model for a dental application.
 *
 * Core Philosophy:
 * The security model is built around the "dentist" as the primary user and owner of data.
 * All data, including X-ray images and their analysis results, is private and
 * can only be accessed by the dentist who created it. Access is controlled using the
 * user's Firebase Authentication UID.
 *
 * Data Structure:
 * Data is organized hierarchically to reflect ownership clearly:
 * - /dentists/{dentistId}: Stores the profile for each dentist.
 * - /dentists/{dentistId}/xray_images/{xrayImageId}: A subcollection for images owned by the dentist.
 * - /dentists/{dentistId}/xray_images/{xrayImageId}/analysis_results/{analysisResultsId}: A nested subcollection for results related to a specific image.
 * This structure leverages path-based security, making rules simple and efficient.
 *
 * Key Security Decisions:
 * - No User Listing: It is not possible to query or list the root `dentists` collection. This
 *   protects user privacy by preventing enumeration of all dentists in the system.
 * - Default Deny: Access is denied by default. Rules explicitly grant permissions only to the
 *   authenticated owner of a specific data tree.
 * - Prototyping Flexibility: These rules focus on authorization (who can access what) but
 *   are flexible on data shapes. They do not validate most fields (e.g., firstName, findings),
 *   allowing for rapid development. However, fields critical for establishing ownership
 *   (e.g., dentistId) are validated to ensure relational integrity.
 *
 * Denormalization for Authorization:
 * To create simpler, more performant rules, the `dentistId` is denormalized and stored directly
 * on each `XRayImage` document. This allows security rules to validate ownership without needing
 * to perform extra `get()` calls to parent documents, which is a significant performance
 * and cost optimization.
 */
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the core function for verifying document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the document being accessed already exists.
     * Used in update and delete operations to prevent writes to non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines ownership and existence checks for secure update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Validates required data integrity fields for Dentist profile creation.
     * Ensures the document ID is consistent with the user's auth UID.
     */
    function hasValidDentistDataOnCreate(dentistId) {
      let data = request.resource.data;
      return data.id == dentistId;
    }

    /**
     * Validates data integrity for Dentist profile updates.
     * Ensures the unique ID of the dentist cannot be changed after creation.
     */
    function hasValidDentistDataOnUpdate() {
      let data = request.resource.data;
      return data.id == resource.data.id;
    }

    /**
     * Validates required data integrity fields for XRayImage creation.
     * Ensures the image is correctly associated with the owning dentist.
     */
    function hasValidXRayImageDataOnCreate(dentistId) {
      let data = request.resource.data;
      return data.dentistId == dentistId;
    }

    /**
     * Validates data integrity for XRayImage updates.
     * Ensures the ownership link (dentistId) cannot be changed.
     */
    function hasValidXRayImageDataOnUpdate() {
      let data = request.resource.data;
      return data.dentistId == resource.data.dentistId;
    }

    /**
     * Validates required data integrity fields for AnalysisResults creation.
     * Ensures the result is correctly associated with its parent X-ray image.
     */
    function hasValidAnalysisResultsDataOnCreate(xrayImageId) {
      let data = request.resource.data;
      return data.xrayImageId == xrayImageId;
    }

    /**
     * Validates data integrity for AnalysisResults updates.
     * Ensures the link to the parent X-ray image cannot be changed.
     */
    function hasValidAnalysisResultsDataOnUpdate() {
      let data = request.resource.data;
      return data.xrayImageId == resource.data.xrayImageId;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to dentist profile documents.
     * @path /dentists/{dentistId}
     * @allow (create) An authenticated user with UID 'dentist123' can create their own profile at `/dentists/dentist123`.
     * @allow (get) An authenticated user with UID 'dentist123' can read their own profile.
     * @deny (list) No user, authenticated or not, can list all documents in the `/dentists` collection.
     * @deny (update) A user with UID 'dentist456' cannot update the profile of 'dentist123'.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /dentists/{dentistId} {
      allow get: if isOwner(dentistId);
      allow list: if false;
      allow create: if isOwner(dentistId) && hasValidDentistDataOnCreate(dentistId);
      allow update: if isExistingOwner(dentistId) && hasValidDentistDataOnUpdate();
      allow delete: if isExistingOwner(dentistId);

      /**
       * @description Controls access to the subcollection of X-ray images for a specific dentist.
       * @path /dentists/{dentistId}/xray_images/{xrayImageId}
       * @allow (create) The dentist with UID 'dentist123' can create a new X-ray image document in their own subcollection.
       * @allow (list) The dentist with UID 'dentist123' can list all images within their `/xray_images` subcollection.
       * @deny (get) A user with UID 'dentist456' cannot read an image belonging to 'dentist123'.
       * @deny (delete) A user with UID 'dentist456' cannot delete an image belonging to 'dentist123'.
       * @principle Enforces document ownership for all operations within a user-specific subcollection.
       */
      match /xray_images/{xrayImageId} {
        allow get: if isOwner(dentistId);
        allow list: if isOwner(dentistId);
        allow create: if isOwner(dentistId) && hasValidXRayImageDataOnCreate(dentistId);
        allow update: if isExistingOwner(dentistId) && hasValidXRayImageDataOnUpdate();
        allow delete: if isExistingOwner(dentistId);

        /**
         * @description Controls access to the analysis results for a specific X-ray image.
         * @path /dentists/{dentistId}/xray_images/{xrayImageId}/analysis_results/{analysisResultsId}
         * @allow (get) The dentist with UID 'dentist123' can read analysis results for their own X-ray image.
         * @allow (create) The dentist with UID 'dentist123' can create new analysis results for their own X-ray image.
         * @deny (list) A user with UID 'dentist456' cannot list the analysis results for an image owned by 'dentist123'.
         * @deny (update) An anonymous user cannot update any analysis results.
         * @principle Enforces transitive ownership; access to this deep subcollection is governed by ownership of the root dentist document.
         */
        match /analysis_results/{analysisResultsId} {
          allow get: if isOwner(dentistId);
          allow list: if isOwner(dentistId);
          allow create: if isOwner(dentistId) && hasValidAnalysisResultsDataOnCreate(xrayImageId);
          allow update: if isExistingOwner(dentistId) && hasValidAnalysisResultsDataOnUpdate();
          allow delete: if isExistingOwner(dentistId);
        }
      }
    }
  }
}